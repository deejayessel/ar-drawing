//
//  Geometry.swift
//  AR Pictionary
//
//  Created by cs326 on 12/1/18.
//  Copyright Â© 2018 davidjlee. All rights reserved.
//

import Foundation
import SceneKit
import CoreGraphics

/**
 A factory class comprised of static functions that generate different geometries.
 */
public class Geometry {
  
  // - MARK: Utility methods
  
  /**
   - Returns: (w, phi) where w is the axis of rotation and phi is the angle of rotation.
   
   - Parameters:
   - u: The vector's tail coordinate.
   - v: The vector's head coordinate.
   */
  private static func rotation(_ u : float3, _ v : float3) -> (axis : float3, angle : Float) {
    // Vector from u to v
    let n = v - u
    let (x,y,z) = (n.x, n.y, n.z)
    
    // Rotating cylinder
    let d = sqrt(pow(x, 2) + pow(z, 2))
    let phi = atan(d/y)
    let w = float3(-z/d, 0, x/d)
    
    return (w, Float.pi - phi) //TODO: see if Float.pi - phi works better
  }
  
  /**
   - Returns: The vertices of a circle given its radius and segmentCount.
   
   - Parameters:
   - radius: The radius of the circle to be generated.
   - segmentCount: The number of segments used in the perimeter of the circle. 48 by default.
   */
  private static func circleVertices(radius : Float, segmentCount : Int = 48) -> [float3] {
    return (0...segmentCount).map {
      let theta  = Float($0)/Float(segmentCount) * 2 * Float.pi
      return float3(x: cos(theta), y: 0, z: sin(theta)) * radius
    }
  }
  
  /**
   - Returns: The vertices of a face rotated to be perpendicular to the vector v.
   
   - Parameters:
   - face: The collection of vertices describing the face in the x-z plane.
   - v: The vector rooted at the origin to which the face will be made perpendicular.
   */
  
  // Rotate face to be perpendicular to vector v
  private static func rotatedFace(face : [float3], _ v : float3) -> [float3] {
    let (w,phi) = rotation(float3(), v)
    let rotationTransform = simd_float4x4(simd_quatf(angle: phi, axis: w))
    return face.map {
      let rotated = float4($0, 1) * rotationTransform
      return float3(rotated)
    }
  }
  
  /**
   - Returns: A SCNNode with a SCNSphere at its center.
   
   - Parameters:
   - center: The center of the SCNNode.
   - radius: The radius of the SCNSphere.
   - color: The color of the SCNSphere.
   */
  private static func pointNode(at center: float3, radius : CGFloat, color : UIColor) -> SCNNode {
    let sphere = SCNSphere(radius: radius)
    sphere.firstMaterial?.diffuse.contents = color
    let node = SCNNode(geometry: sphere)
    node.simdPosition = center
    return node
  }
  
  /**
   - Returns: The geometry generated by interleaving the vectors in face1 and face2.
   */
  private static func interleavedGeometry(face1: [float3], face2: [float3]) -> SCNGeometry {
    let interleaved : [float3] = zip(face1[...] + face1[0...1],
                                     face2[...] + face2[0...1]).flatMap { [$0,$1] }

    // Generate geometry using interleaved points
    let source = SCNGeometrySource(vertices: interleaved.map { SCNVector3($0) })
    let indices = (0...interleaved.count-3).map { UInt8($0) }
    let element = SCNGeometryElement(indices: indices,
                                     primitiveType: .triangleStrip)
    return SCNGeometry(sources: [source], elements: [element])
  }
  
  /**
   - Returns: A closed UIBezierPath representing a set of 3D points.
   
   - Parameter face: The sequence of vectors to be used.  Should represent a closed path.
   */
  private static func path(of face: [float3]) -> UIBezierPath {
    let path = UIBezierPath()
    path.move(to: face.first!.flattened)
    for vertex in face.dropLast() {
      path.addLine(to: vertex.flattened)
    }
    path.close()
    return path
  }
  
  // - MARK: Generators
  
  /**
   Returns a generator for 3D cylinder-line geometries.
   
   Generates the geometry for a whole line.  Geometry consists of cylinders where
   an interface between cylinders is a circle perpendicular to the vector leading from it
   to the next interface.  Cylinder-lines generated in this manner have no cracks at sharp turns,
   but will be distorted if the turn is sufficiently sharp.
   
   - Parameters:
   - radius: The radius of the cylinders used in the line.
   - segmentCount: The number of radial segments to be used in the cylinders.
   
   - Returns: A generator for full line geometries taking a float3 array as input.
   */
  public static func tubeLineGenerator(radius: CGFloat, segmentCount : Int) -> ([float3]) -> SCNNode {
    let circleVertices : [float3] = self.circleVertices(radius: Float(radius),
                                                        segmentCount: segmentCount)
    
    return {
      (vertices : [float3]) in
      
      // Ensure that the generator only runs when there are 2 or more vertices.
      guard vertices.count >= 2 else {
        return SCNNode()
      }
      
      // The parent node of all nodes generated in the loop; to be returned
      let parent = SCNNode()
      
      // Construct a set of tubes (uncapped cylinders) and add caps at end
      for i in 1..<vertices.count-1 {
        let u = vertices[i-1]
        let v = vertices[i]
        let w = vertices[i+1]
        
        let firstCircle : [float3] = rotatedFace(face: circleVertices, v - u)
        let secondCircle : [float3] = rotatedFace(face: circleVertices, w - v).map {
          $0 + (v - u) //Translate second circle face by vector difference of u and v
        }
        
        let geometry = interleavedGeometry(face1: firstCircle, face2: secondCircle)

        // FOR TESTING: set line color red
        geometry.firstMaterial?.diffuse.contents = UIColor.red
        
        // Add to SCNNode
        let node = SCNNode(geometry: geometry)
        node.simdPosition = u
        parent.addChildNode(node)
      }
      return parent
    }
  }
  
  /**
   Returns a generator for 3D cylinders.
   
   Generates a cylinder connecting a point u to another point v.  Lines composed of such
   cylinders will have constant thickness but may have cracks at sharp turns (wedges where
   no cylinders have been drawn).

   - Parameter radius: The radius of each cylinder.

   - Returns: A function that generates cylinder geometries between two points.
   
   */
  public static func cylinderGenerator(radius: CGFloat) -> (float3, float3) -> SCNNode {
    return { (u : float3, v : float3) -> SCNNode in
      let cylinder = SCNCylinder(radius: radius, height: CGFloat(u.distance(to: v)))
      cylinder.heightSegmentCount = 1
      
      // Get rotation axis and angle for the vector from u to v
      let (w, phi) = self.rotation(u, v)
      
      // Rotate cylinder by phi about w
      let node = SCNNode(geometry: cylinder)
      node.simdPosition = u.midpoint(with: v) //Translate node to position of src node
      node.simdLocalRotate(by: simd_quatf(angle: phi, axis: w))
      
      return node
    }
  }
  
  /**
   Returns a segment-cylinder generator that fills in gaps between cylinders.
   
   - Parameter radius: The radius of each cylinder.

   - Returns: A function that generates cylinder geometries between three points.
   */
    public static func jointedcylinderGenerator(radius: CGFloat) -> (float3, float3, float3) -> SCNNode {
      assertionFailure("Not implemented")
      return { (u: float3, v: float3, w: float3) -> SCNNode in
        let cylinderNodes : [SCNNode] = [(u,v), (v,w)].map(cylinderGenerator(radius: radius))
  
        // terminal face of first cylinder, initial face of second cylinder
        let firstTerminal : [float3] = rotatedFace(face: circleVertices(radius: Float(radius)), v - u)
        let secondInitial : [float3] = rotatedFace(face: circleVertices(radius: Float(radius)), w - v)

        // ankle joint
        let ankleGeometry = interleavedGeometry(face1: firstTerminal, face2: secondInitial)
        let ankleNode = SCNNode(geometry: ankleGeometry)
        ankleNode.simdPosition = v

        let parent = SCNNode()
        for node in cylinderNodes + [ankleNode] {
          parent.addChildNode(node)
        }

        return parent
      }
    }
  
  /**
   - Returns: A generator for a rectangle-faced brush.
   
   - Parameters:
   - width: The width of the brush face (x-y plane).
   - height: The height of the brush face (x-y plane).
   - color: The color of the brush.
   */
  public static func rectangleBrushGenerator(width: CGFloat,
                                             height: CGFloat,
                                             color: UIColor) -> (float3, float3) -> SCNNode {
    let w = Float(width), h = Float(height)
    let wideBrush : [float3] = [ // corner vertices
      float3(-w, 0, -h),
      float3(w, 0, -h),
      float3(-w, 0, h),
      float3(w, 0, h)
    ]
    return faceTubeGenerator(face: wideBrush, color: color)
  }
  
  /**
   - Returns: A generator for prisms of the specified face.

   - Parameters:
   - face: The face to be used in generating brush-prisms as defined in the x-z plane.
   - color: The color of the brush.
   */
  private static func faceTubeGenerator(face : [float3], color : UIColor) -> (float3, float3) -> SCNNode {
    assert(!face.isEmpty)
    return { (u: float3, v: float3) -> SCNNode in
      
      let geometry = SCNShape(path: path(of: face),
                              extrusionDepth: CGFloat(u.distance(to: v)))
      geometry.firstMaterial?.diffuse.contents = color

      let (w,phi) = rotation(u, v)
      
      // Add to SCNNode
      let node = SCNNode(geometry: geometry)
      node.simdPosition = u
      node.simdLocalRotate(by: simd_quatf(angle: phi, axis: w))
      return node
    }
  }
  
}
