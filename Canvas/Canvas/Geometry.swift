//
//  Geometry.swift
//  AR Pictionary
//
//  Created by cs326 on 12/1/18.
//  Copyright Â© 2018 davidjlee. All rights reserved.
//

import Foundation
import SceneKit
import CoreGraphics

/**
 A factory class comprised of static functions that generate different geometries.
 */
public class Geometry {
  
  // - MARK: Utility methods
  
  /**
   - Returns: (w, phi) where w is the axis of rotation and phi is the angle of rotation.
   
   - Parameters:
   - u: The vector's tail coordinate.
   - v: The vector's head coordinate.
   */
  private static func rotation(_ u : float3, _ v : float3) -> (axis : float3, angle : Float) {
    // Vector from u to v
    let n = v - u
    let (x,y,z) = (n.x, n.y, n.z)
    
    // Rotating cylinder
    let d = sqrt(pow(x, 2) + pow(z, 2))
    let phi = atan(d/y)
    let w = float3(-z/d, 0, x/d)
    
    return (w, Float.pi - phi) // make phi start at top
  }
  
  /**
   - Returns: The vertices of a circle given its radius and segmentCount.
   
   - Parameters:
   - radius: The radius of the circle to be generated.
   - segmentCount: The number of segments used in the perimeter of the circle. 48 by default.
   */
  private static func circleVertices(radius : Float, segmentCount : Int = 48) -> [float3] {
    return (0...segmentCount).map {
      let theta  = Float($0)/Float(segmentCount) * 2 * Float.pi
      return float3(x: cos(theta), y: 0, z: sin(theta)) * radius
    }
  }
  
  /**
   - Returns: The vertices of a face rotated to be perpendicular to the vector v.
   
   - Parameters:
   - face: The collection of vertices describing the face in the x-z plane.
   - v: The vector rooted at the origin to which the face will be made perpendicular.
   */
  
  // Rotate face to be perpendicular to vector v
  private static func rotatedFace(face : [float3], _ v : float3) -> [float3] {
    let (w,phi) = rotation(float3(), v)
    let rotationTransform = float4x4(simd_quatf(angle: phi, axis: w))
    return face.map {
      let rotated = float4($0, 1) * rotationTransform
      return float3(rotated)
    }
  }
  
  /**
   - Returns: A SCNNode with a SCNSphere at its center.
   
   - Parameters:
   - center: The center of the SCNNode.
   - radius: The radius of the SCNSphere.
   - color: The color of the SCNSphere.
   */
  private static func pointNode(at center: float3, radius : CGFloat, color : UIColor) -> SCNNode {
    let sphere = SCNSphere(radius: radius)
    sphere.firstMaterial?.diffuse.contents = color
    let node = SCNNode(geometry: sphere)
    node.simdPosition = center
    return node
  }
  
  /**
   - Returns: The geometry generated by interleaving the vectors in face1 and face2.
   */
  private static func interleavedGeometry(face1: [float3], face2: [float3]) -> SCNGeometry {
    let interleaved : [float3] = zip(face1[...] + face1[0...1],
                                     face2[...] + face2[0...1]).flatMap { [$0,$1] }

    // Generate geometry using interleaved points
    let source = SCNGeometrySource(vertices: interleaved.map { SCNVector3($0) })
    let indices = (0...interleaved.count-3).map { UInt8($0) }
    let element = SCNGeometryElement(indices: indices,
                                     primitiveType: .triangleStrip)
    return SCNGeometry(sources: [source], elements: [element])
  }
  
  /**
   - Returns: A closed UIBezierPath representing a set of 3D points.
   
   - Parameter face: The sequence of vectors to be used.  Should represent a closed path.
   */
  private static func path(of face: [float3]) -> UIBezierPath {
    let path = UIBezierPath()
    path.move(to: face.first!.flattened)
    for vertex in face.dropLast() {
      path.addLine(to: vertex.flattened)
    }
    path.close()
    return path
  }
  
  // - MARK: Generators
  
  /**
   Returns a generator for 3D cylinders.
   
   Generates a cylinder connecting a point u to another point v.  Lines composed of such
   cylinders will have constant thickness but may have cracks at sharp turns (wedges where
   no cylinders have been drawn).

   - Parameter radius: The radius of each cylinder.

   - Returns: A function that generates cylinder geometries between two points.
   
   */
  public static func cylinderGenerator() -> ([float3], Context) -> SCNNode {
    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 2)
      let u = m[m.count-2], v = m[m.count-1]
      
      let cylinder = SCNCylinder(radius: context.lineRadius,
                                 height: CGFloat(u.distance(to: v)))
      cylinder.heightSegmentCount = 1
      cylinder.firstMaterial?.diffuse.contents = context.color

      // Get rotation axis and angle for the vector from u to v
      let (w, phi) = self.rotation(u, v)
      
      // Rotate cylinder by phi about w
      let node = SCNNode(geometry: cylinder)
      node.simdPosition = u.midpoint(with: v) //Translate node to position of src node
      node.simdLocalRotate(by: simd_quatf(angle: phi, axis: w))
      
      return node
    }
  }
  
  /**
   Returns a segment-cylinder generator that fills in gaps between cylinders.
   
   - Parameter radius: The radius of each cylinder.
   
   - Returns: A function that generates cylinder geometries between three points.
   */
  public static func jointedcylinderGenerator() -> ([float3], Context) -> SCNNode {
    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 3)
      let u = m[m.count-3], v = m[m.count-2], w = m[m.count-1]
      
      let cylinderGenerator = self.cylinderGenerator()
      let cylinderNodes : [SCNNode] = [[u,v], [v,w]].map { cylinderGenerator($0,context) }
      
      // terminal face of first cylinder, initial face of second cylinder
      let firstTerminal : [float3] = rotatedFace(face: circleVertices(radius: Float(context.lineRadius)), v - u)
      let secondInitial : [float3] = rotatedFace(face: circleVertices(radius: Float(context.lineRadius)), w - v).map {
        $0 + v - u
      }
      
      // ankle joint
      let ankleGeometry = interleavedGeometry(face1: firstTerminal, face2: secondInitial)
      let ankleNode = SCNNode(geometry: ankleGeometry)
      ankleNode.simdPosition = v
      
      let parent = SCNNode()
      for node in cylinderNodes + [ankleNode] {
        parent.addChildNode(node)
      }
      return parent
    }
  }
  
  /**
   - Returns: A generator for a flat brush.
   
   - Parameters:
   - width: The width of the brush face (x-y plane).
   - color: The color of the brush.
   */
  public static func flatBrushGenerator() -> ([float3], Context) -> SCNNode {
    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 3)

      let width = Float(context.lineRadius*2)
      let wideBrush : [float3] = [ // corner vertices
        float3(-width, 0, 0),
        float3(width, 0, 0)
      ]

      let generator = smoothTubeGenerator(face: wideBrush)
      let u = m[m.count-3], v = m[m.count-2], w = m[m.count-1]
      return generator(u, v, w, context)
    }
  }

  /**
   Returns a smoothed curve generator using Bezier curves.  Generator takes a 4x3 matrix,
   equivalent to 4 float3's.
   
   */
  public static func bezierCurveGenerator() -> ([float3], Context) -> SCNNode {
    func basis(t : Float) -> float4 { // needs to be here so generator can use in init
      return float4(1, t, powf(t, 2), powf(t, 3))
    }
    let splineMatrix = float4x4(rows: [float4(1, -3, 3, -1),
                                       float4(0,3,-6,3),
                                       float4(0, 0, 3, -3),
                                       float4(0, 0, 0, 1)])

    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 4)
      let matrix = float4x3(Array(m.suffix(4))) * splineMatrix
      let parametrization = { (t: Float) -> float3 in
        let result = matrix * basis(t: t)
        return result
      }
      
      let parent = SCNNode()
      let vertices = stride(from: 0.0, to: Float(context.detail), by: 1.0).map(parametrization)
      let cylinderGenerator = self.cylinderGenerator()
      for i in 0...vertices.count-2 {
        let cylinderNode = cylinderGenerator(Array(vertices[i...i+1]), context)
        parent.addChildNode(cylinderNode)
      }
      return parent
    }
  }
  
  /**
   - Returns: A generator for prisms with smoothing between prisms.
   
   - Parameters:
   - face: The face to be used in generating brush-prisms as defined in the x-z plane.
   - color: The color of the brush.
   */
  private static func smoothTubeGenerator(face : [float3]) -> (float3, float3, float3, Context) -> SCNNode {
    assert(!face.isEmpty)
    return { (u: float3, v: float3, w: float3, context: Context) -> SCNNode in
      let firstFace : [float3] = rotatedFace(face: face, v - u)
      let secondFace : [float3] = rotatedFace(face: face, w - v).map { $0 + (v - u) }
      let pipe = interleavedGeometry(face1: firstFace, face2: secondFace)
      pipe.firstMaterial?.diffuse.contents = context.color
      pipe.firstMaterial?.isDoubleSided = true
      
      // Add to SCNNode
      let node = SCNNode(geometry: pipe)
      node.simdPosition = u
      return node
    }
  }
  
}
