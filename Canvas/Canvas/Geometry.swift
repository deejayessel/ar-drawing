//
//  Geometry.swift
//  AR Pictionary
//
//  Created by cs326 on 12/1/18.
//  Copyright Â© 2018 davidjlee. All rights reserved.
//

import Foundation
import SceneKit
import CoreGraphics

/**
 A factory class comprised of static functions that generate different geometries.
 */
public class Geometry {
  
  // - MARK: Utility methods
  
  /**
   - Returns: (w, phi) where w is the axis of rotation and phi is the angle of rotation.
   
   - Parameters:
   - u: The vector's tail coordinate.
   - v: The vector's head coordinate.
   */
  private static func rotation(_ u : float3, _ v : float3) -> (axis : float3, angle : Float) {
    // Vector from u to v
    let n = v - u
    let (x,y,z) = (n.x, n.y, n.z)
    
    // Rotating cylinder
    let d = sqrt(pow(x, 2) + pow(z, 2))
    let phi = atan(d/y)
    let w = float3(-z/d, 0, x/d)
    
    return (w, Float.pi - phi) // make phi start at top
  }
  
  /**
   - Returns: The vertices of a circle given its radius and segmentCount.
   
   - Parameters:
   - radius: The radius of the circle to be generated.
   - segmentCount: The number of segments used in the perimeter of the circle. 48 by default.
   */
  private static func circleVertices(radius : Float, segmentCount : Int = 48) -> [float3] {
    return (0...segmentCount).map {
      let theta  = Float($0)/Float(segmentCount) * 2 * Float.pi
      return float3(x: cos(theta), y: 0, z: sin(theta)) * radius
    }
  }
  
  /**
   - Returns: The vertices of a face rotated to be perpendicular to the vector v.
   
   - Parameters:
   - face: The collection of vertices describing the face in the x-z plane.
   - v: The vector rooted at the origin to which the face will be made perpendicular.
   */
  
  // Rotate face to be perpendicular to vector v
  private static func rotatedFace(face : [float3], _ v : float3) -> [float3] {
    let (w, phi) = rotation(float3(), v) //
    let rotationTransform = float4x4(simd_quatf(angle: Float.pi - phi, axis: w))
    return face.map {
      let rotated = float4($0, 1) * rotationTransform
      return float3(rotated)
    }
  }
  
  /**
   - Returns: A SCNNode with a SCNSphere at its center.
   
   - Parameters:
   - center: The center of the SCNNode.
   - radius: The radius of the SCNSphere.
   - color: The color of the SCNSphere.
   */
  private static func pointNode(at center: float3, radius : CGFloat, color : UIColor) -> SCNNode {
    let sphere = SCNSphere(radius: radius)
    sphere.firstMaterial?.diffuse.contents = color
    let node = SCNNode(geometry: sphere)
    node.simdPosition = center
    return node
  }
  
//  private static func shortestLine(p1: float3, p2: float3, q1: float3, q2: float3) -> (float3, float3) {
//    func d(_ m: float3, _ n: float3, _ o: float3, _ p: float3) -> Float {
//      return (m.x - n.x) * (o.x - p.x) + (m.y - n.y) * (o.y - p.y) + (m.z - n.z) * (o.z - p.z)
//    }
//
//    // mua = ( d1343 d4321 - d1321 d4343 ) / ( d2121 d4343 - d4321 d4321 )
//    let mu_a = d(p1, q1, q2, q1) * d(q2, q1, p2, p1) - d(p1, q1, p2, p1) * d(q2, q1, q2, q1) /
//      d(p2, p1, p2, p1) * d(q2, q1, q2, q1) - powf(d(q2, q1, p2, p1), 2)
//
//    // mub = ( d1343 + mua d4321 ) / d4343
//    let mu_b = (d(p1, q1, q2, q1) + mu_a * d(q2, q1, p2, p1)) / d(q2, q1, q2, q1)
//
//    // Pa = P1 + mua (P2 - P1)
//    // Pb = P3 + mub (P4 - P3)
//    let p_a = p1 + mu_a * (p2 - p1)
//    let p_b = q1 + mu_b * (q2 - q1)
//
//    return (p_a, p_b)
//  }
//
//  private static func cleanInterleave(face1: [float3], face2: [float3], u: float3, v: float3) -> SCNGeometry {
//    // prevent self-intersection by rotating 180 deg
//    let (start, end) = shortestLine(p1: face1.first!, p2: face2.first!,
//                                    q1: u, q2: v)
//
//    if simd_length(end - start).isNaN {
//      // if intersects, rotate face
//      NSLog("Interleaving cleanly")
//      let newFace2: [float3] = Array(face2.suffix(face2.count/2) + face2.prefix(face2.count/2))
//      return interleavedGeometry(face1: face1, face2: newFace2)
//    } else {
//      NSLog("\(simd_length(end - start))")
//      return interleavedGeometry(face1: face1, face2: face2)
//    }
//  }
  
  /**
   - Returns: The geometry generated by interleaving the vectors in face1 and face2.
   */
  private static func interleavedGeometry(face1: [float3], face2: [float3]) -> SCNGeometry {
    
    let interleaved : [float3] = zip(face1[...] + face1[0...0],
                                     face2[...] + face2[0...0]).flatMap { [$0,$1] }

    // Generate geometry using interleaved points
    let source = SCNGeometrySource(vertices: interleaved.map { SCNVector3($0) })
    let indices = (0...interleaved.count-3).map { UInt8($0) }
    let element = SCNGeometryElement(indices: indices,
                                     primitiveType: .triangleStrip)
    let geometry = SCNGeometry(sources: [source], elements: [element])
    geometry.firstMaterial?.isDoubleSided = true

    return geometry
  }
  
  /**
   - Returns: A closed UIBezierPath representing a set of 3D points.
   
   - Parameter face: The sequence of vectors to be used.  Should represent a closed path.
   */
  private static func path(of face: [float3]) -> UIBezierPath {
    let path = UIBezierPath()
    path.move(to: face.first!.flattened)
    for vertex in face.dropLast() {
      path.addLine(to: vertex.flattened)
    }
    path.close()
    return path
  }
  
  // - MARK: Generators
  
  /**
   Returns a generator for 3D cylinders.
   
   Generates a cylinder connecting a point u to another point v.  Lines composed of such
   cylinders will have constant thickness but may have cracks at sharp turns (wedges where
   no cylinders have been drawn).

   - Parameter radius: The radius of each cylinder.

   - Returns: A function that generates cylinder geometries between two points.
   
   */
  public static func cylinderGenerator() -> ([float3], Context) -> SCNNode {
    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 2)
      let u = m[m.count-2], v = m[m.count-1]
      
      return cylinder2Generator()(u, v, context)
    }
  }
  
  private static func cylinder2Generator() -> (float3, float3, Context) -> SCNNode {
    return { (u: float3, v: float3, context: Context) -> SCNNode in

      let cylinder = SCNCylinder(radius: context.lineRadius,
                                 height: CGFloat(u.distance(to: v)))
      cylinder.heightSegmentCount = 1
      cylinder.firstMaterial?.diffuse.contents = context.color
      
      // Get rotation axis and angle for the vector from u to v
      let (w, phi) = self.rotation(u, v)
      
      // Rotate cylinder by phi about w
      let node = SCNNode(geometry: cylinder)
      node.simdPosition = u.midpoint(with: v) //Translate node to position of src node
      node.simdLocalRotate(by: simd_quatf(angle: phi, axis: w))
      
      return node
    }
  }
  
  /**
   Returns a segment-cylinder generator that fills in gaps between cylinders.
   
   - Parameter radius: The radius of each cylinder.
   
   - Returns: A function that generates cylinder geometries between three points.
   */
  public static func jointedCylinderGenerator() -> ([float3], Context) -> SCNNode {
    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 3)
      let u = m[m.count-3], v = m[m.count-2], w = m[m.count-1]
      
      let cylinderNode = self.cylinder2Generator()(u, v, context)
      
      // terminal face of first cylinder, initial face of second cylinder
      let firstTerminal : [float3] = rotatedFace(face: circleVertices(radius: Float(context.lineRadius)), v - u)
      let secondInitial : [float3] = rotatedFace(face: circleVertices(radius: Float(context.lineRadius)), w - v)
      
      // ankle joint
      let ankleGeometry = interleavedGeometry(face1: firstTerminal, face2: secondInitial)
      let ankleNode = SCNNode(geometry: ankleGeometry)
      ankleNode.simdPosition = v
      
      let parent = SCNNode()
      for node in [cylinderNode, ankleNode] {
        parent.addChildNode(node)
      }
      return parent
    }
  }
  
  /**
   - Returns: A generator for a flat brush.
   
   - Parameters:
   - width: The width of the brush face (x-y plane).
   */
  public static func flatBrushGenerator() -> ([float3], Context) -> SCNNode {
    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 4)
      //assert(m.count >= 3)

      let width = Float(context.lineRadius*2)
      let wideBrush : [float3] = [ // corner vertices
        float3(-width, 0, 0),
        float3(width, 0, 0)
      ]

      let generator = connectedTube4Generator(face: wideBrush)
      //smoothTubeGenerator(face: wideBrush)
      return generator(m[m.count-4], m[m.count-3], m[m.count-2], m[m.count-1], context)
    }
  }

  /**
   Returns a smoothed curve generator using Bezier curves.
   */
  public static func bezierCurveGenerator() -> ([float3], Context) -> SCNNode {
    func basis(t : Float) -> float4 { // needs to be here so generator can use in init
      return float4(1, t, powf(t, 2), powf(t, 3))
    }
    let splineMatrix = float4x4(rows: [float4(1, -3, 3, -1),
                                       float4(0,3,-6,3),
                                       float4(0, 0, 3, -3),
                                       float4(0, 0, 0, 1)])

    return { (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 4)
      let matrix = float4x3(Array(m.suffix(4))) * splineMatrix
      let parametrization = { (t: Float) -> float3 in
        return matrix * basis(t: t)
      }
      
      let parent = SCNNode()
      let vertices = stride(from: 0.0, to: 1.0, by: 1.0/Float(context.detail)).map(parametrization)
      let generator = self.cylinder2Generator()
      for i in 0...vertices.count-2 {
        let cylinderNode = generator(vertices[i], vertices[i+1], context)
        parent.addChildNode(cylinderNode)
      }
      return parent
    }
  }
  
  /**
   - Returns: A generator for prisms with smoothing between prisms.
   
   - Parameters:
   - face: The face to be used in generating brush-prisms as defined in the x-z plane.
   */
  private static func smoothTubeGenerator(face : [float3]) -> (float3, float3, float3, Context) -> SCNNode {
    assert(!face.isEmpty)
    return { (u: float3, v: float3, w: float3, context: Context) -> SCNNode in
      let firstFace : [float3] = rotatedFace(face: face, v - u)
      let secondFace : [float3] = rotatedFace(face: face, w - v).map { $0 + (v - u) }
      let pipe = interleavedGeometry(face1: firstFace, face2: secondFace)
      pipe.firstMaterial?.diffuse.contents = context.color
      pipe.firstMaterial?.isDoubleSided = true
      
      // Add to SCNNode
      let node = SCNNode(geometry: pipe)
      node.simdPosition = u
      return node
    }
  }
  
  /**
   A primitive prism-generator that smooths connections between prisms with sharp turns.

   Given a,b,c,d as vertices, the prism generated will have faces defined at b and c.
   Face B corresponding to vertex b will be perpendicular to the vector from a to c;
   face C corresponding to vertex c will be perpendicular to the vector from b to d.

   - Returns: A generator for prisms where connecting face planes are perpendicular to
    the vector connecting adjacent vertices.

   - Parameters:
   - face: The face to be used in generating brush-prisms as defined in the x-z plane.
   */
  private static func connectedTube4Generator(face: [float3]) -> (float3, float3, float3, float3, Context) -> SCNNode {
    assert(face.count >= 3)
    return {
      (a: float3, b: float3, c: float3, d: float3, context: Context) -> SCNNode in
      
      let face1 = rotatedFace(face: face, c - a).map { $0 + (b - a) } //translate to b
      let face2 = rotatedFace(face: face, d - b).map { $0 + (c - a) } //translate to c
      let pipe = interleavedGeometry(face1: face1, face2: face2)
      pipe.firstMaterial?.diffuse.contents = context.color
      pipe.firstMaterial?.isDoubleSided = true
      
      let node = SCNNode(geometry: pipe)
      node.simdPosition = a //Check
      return node
    }
  }
  
  /**
   A cylinder generator that makes intermediate faces perpendicular to the vector between
   the adjacent vertices.
   */
  public static func connectedCylinderGenerator() -> ([float3], Context) -> SCNNode {
    return {
      (m: [float3], context: Context) -> SCNNode in
      assert(m.count >= 4)
      
      let generator = connectedTube4Generator(face: circleVertices(radius: Float(context.lineRadius)))
      return generator(m[m.count-4], m[m.count-3], m[m.count-2], m[m.count-1], context)
    }
  }
  
  /**
   Checks whether the curve through a,b,c is too sharp or too straight and adjusts accordingly,
   returning an array of points to be used.

   - If angle<a,b,c> is close enough to 180, returns [a, c].
   - If angle<a,b,c> is close enough to 0, adds another segment from the midpoint of a and b
     to the midpoint of b and c.
   - Otherwise leaves [a,b,c] alone.
   */
  private static func corrected3Points(_ a: float3, _ b: float3, _ c: float3) -> [float3] {
    // angle btwn vector<b to a> and vector<b to c>
    let angle = float3.angle(a - b, c - b)
    
    if angle.distance(to: 180) < 5 { // straighten straight
      return [a, c]
    } else if angle.distance(to: 0) < 30 { // smooth acute
      // Add another segment from midpoint<a,b> to midpoint<b,c>
      return [ a, a.midpoint(with: b), b.midpoint(with: c), c]
    } else {
      return [a,b,c]
    }
  }

}
